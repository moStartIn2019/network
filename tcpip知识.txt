TCP和UDP的区别
1 TCP是面向连接的，UDP是面向无连接的
2 TCP是面向字节流的，UDP是基于数据报的
    UDP因为仅仅继承了IP层的特性，而TCP为了维护状态，将一个IP包变成了字节流
    TCP会精准记录哪些数据发送了，哪些数据被对方接收了，
    哪些没有被接收到，而且保证数据包按顺序到达，不允许半点差错，这是有状态的。
    当意识到丢包了或者网络环境不佳，TCP会根据具体情况调整自己的行为，控制自己的
    发送速度或者重发，这是可控的
    总结就是，UDP是无状态的，不可控的。TCP是有状态的，可靠的。
3 TCP保证数据准确性，UDP可能丢包
4 TCP保证数据顺序，UDP不保证数据顺序
   首先为了保证顺序性，每个包都有一个 ID
==============
TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力
凡是需要对端确认的，一定消耗TCP报文的序列号。
SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。
==============
为什么不是两次？
根本原因: 无法确认客户端的接收能力！
分析如下:
如果是两次，这就带来了连接资源的浪费。你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。
看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，
就默认建立连接，但是现在客户端已经断开了，这就带来了连接资源的浪费。
==============
为什么不是四次？
三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？
当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。
==============
三次握手过程中可以携带数据么？
第三次握手的时候，可以携带。前两次握手不能携带数据。
如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。
第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。
==============
TCP 并不是一个轮询的协议
大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。
试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。
这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。
不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？
站在应用的角度:
7200s 也就是两个小时检测一次，时间太长
时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接
因此是一个比较尴尬的设计
==============
如果是三次挥手会有什么问题？
等于说服务端将ACK和FIN的发送合并为一次挥手，
这个时候长时间的延迟
可能会导致客户端误以为FIN没有到达客户端，
从而让客户端不断的重发FIN。
==============
TCP慢启动： 
	TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。
多条TCP连接竞争带宽： 
	如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
HTTP/1.1队头阻塞： 
	尽管HTTP/1.1长链接可以通过 一个TCP连接 传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。
为了解决以上几个问题，
HTTP/2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用